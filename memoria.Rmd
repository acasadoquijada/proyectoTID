---
title: "proyectoTID"
author: "Alejandro Casado Quijada y Gustavo Rivas Gervillas"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(arules)
library(plyr)
library(ggplot2)
library(sampling)
```

## Introducci칩n

## Descripci칩n del dataset

Este dataset contiene datos recogidos de la aplicacion *PokemonGo*, esta aplicaci칩n es un juego de realidad aumeta que emplea el GPS del m칩vil para principalmente localizar y capturar pokemon en el mundo real. El dataset contiene 296021 muestras cada una de las cuales dispone de los siguientes campos:

* **pokemonId**: el identificador del pokemon, denota su clase.
* **latitude**: latitud de la posici칩n donde se ha localizado el pokemon.
* **longitude**: longitud de la posici칩n donde se ha localizado el pokemon.
* **appearedLocalTime**: momento exacto en el que se encontr칩 el pokemon, con el formato yyyy-mm-ddThh-mm-ss.ms.
* **X_id**: la ficha del dataset no proporciona informaci칩n sobre qu칠 representa este dato, de hecho hemos [preguntado en la propia web](https://www.kaggle.com/semioniy/predictemall/discussion/24061#144095) pero no hemos obtenido respuesta. No obstante viendo el dataset no parece ser m치s que una c칩digo identificador de la muestra. 
* **cellId 90-5850m**: la localizaci칩n goegr치fica del pokemon proyectada en una celda S2.
* **appearedTimeOfDay**: momento del d칤a en el que apareci칩 el pokemon (night, evening, afternoon, morning).
* **appearedHour**: hora local de una observaci칩n del pokemon.
* **appearedMinute**: minuto local de una observaci칩n del pokemon.
* **appearedDayOfWeek**: d칤a de la semana en la que se produjo el avistamiento (Monday, Tuesday, Wednesday, Thursday, Friday, Saturdy, Sunday).
* **appearedDay**: d칤a del avistamiento.
* **appearedMonth**: mes del avistamiento.
* **appearedYear**: a침o del avistamiento.
* **terrainType**: tipo del terreno donde se avist칩 el pokemon. Este dato viene dado por un valor n칰mero seg칰n una [tabla de tipos de terreno](http://glcf.umd.edu/data/lc/).
* **closeToWater**: si est치 el pokemon a 100m del agua o no.
* **city**: ciudad donde se ha visto el pokemon.
* **continent**: continente donde se ha avistado el pokemon.
* **weather**: un string indicando el tiempo que hac칤a en el momento del avistamiento.
* **temperature**: temperatura en grados Celsius en el momento del avistamiento.
* **windSpeed**: velocidad del viento en el momento del avistamiento km/h.
* **windBearing**: direcci칩n del viento entre 0 y 360 grados.
* **pressure**: presi칩n en el momento del avistamiento en bares.
* **weatherIcon**: el tiempo atmosf칠rico en el momento del avistamiento clasificado seg칰n un sistema de categor칤as m치s simple que el empleado en *weather* (fog, clear-night, partly-cloudy-night, partly-cloudy-day, cloudy, clear-day, rain, wind).
* **sunriseMinutesMidnight**: tiempo de la aparici칩n relativo al amanecer.
* **sunsetMinutesBefore**: tiempo de la aparici칩n relativo a la puesta de sol.
* **population density**: densidad de poblaci칩n por $km^2$ en un avistamiento.
* **urbal-rural**: c칩mo de urbana es la localizaci칩n donde apareci칩 el pokemon relativa a la *population density* (<200 rural, >= 200 && < 400 midUrban, >= 400 && < 800 subUrban, >800 urban).
* **gymDistanceKm**: distancia al gimnasio m치s cercano al punto de aparici칩n del pokemon.
* **pokestopDistanceKm**: distancia a la pokestop m치s cercana al punto de aparicion del pokemon.
* **gymIn100m** - **pokestopIn5000m**: son atributos booleanos que indican si hay un gimnasio o una pokestop a 100m/250m/500m/1000m/2500m/5000m de la localizaci칩n donde se avist칩 el pokemon.
* **cooc1** - **cooc151**: booleano que indica si el avistamiento de un pokemon coincidi칩 con el de otro (de una clase entre 1 y 151) en un radio de 100m y en un rango de tiempo de 24 horas.
* **class** dice qu칠 pokemon se trata, y en la p치gina del dataset indica que es el atributo a predecir.
## Preprocesamiento

En primer lugar vamos a ver cu치ntas muestras y atributos tiene nuestro dataset. Adem치s veremos si las clases est치n balanceadas, para echo emplearemos el comando `xtab`:

```{r}
ds <- read.csv("300k.csv")
```

```{r}
cat("Hay un total de " , nrow(ds) , " muestras.\n")
cat("Cada muestra tiene " , ncol(ds) , " atributos.\n")
```

Vamos a proceder a eliminar el atributo **appearedLocalTime**, la eliminamos en primer lugar por la dificultad de trabajar con este dado, el cual podr칤amos transformar en una serie de variables que desglosasen su contenido, no obstante tenemos otros atributos que ya lo hacen, como son la hora, el d칤a, el mes y el a침o del avistamiento. Por otro lado vamos a eleminar tambi칠n el atributo **X_id** que como ya hemos comentado no sabemos qu칠 representa. Adem치s teniendo en cuenta que la aplicaci칩n se lanz칩 el d칤a 6 de julio de 2016, es claro que no el a침o del avistamiento no aporta ninguna informaci칩n, con lo que tambi칠n eleminaremos el atributo **appearedYear**.

```{r}
ds <- subset(ds, select = -c(appearedLocalTime, X_id, appearedYear))
```

Viendo el dataset nos hemos dado cuenta de que para los atributos booleanos que nos indican si hay un gimnasio o una pokeparada a una distancia determinada del lugar de avistamiento del pokemon, siguen un patr칩n, y es que, al parecer, estas variables lo que indican es si hay un gimnasio o una pokeparada **en un radio** de una determinada longitud, con lo cual en cuanto el atributo que indica si hay un gimansio a una distancia es cierto, el resto de atributos que indican si hay un gimnasio a una distancia mayor tambi칠n lo son. Lo mismo sucede con las paradas. Entonces una vez hayamos confirmado esto, como la existencia de un gimnasio o una pokeparada en un radio determinado implica la existencia en un radio mayor, podremos eliminar, sin p칠rdida de informaci칩n, todos estos atributos y quedarnos 칰nicamente con los atributos **gymDistanceKm** y **pokestopDistanceKm**, que resumir칤an la informaci칩n contenida en los otros atributos. Para tratar de comprobar esto vamos a hacer uso de las reglas de asociaci칩n con el paquete *arules*:

```{r}
booleansGyms = subset(ds, select = c(gymIn100m, gymIn250m, gymIn500m, gymIn1000m, gymIn2500m, gymIn5000m))
reglas = apriori(booleansGyms, parameter = list(support = 0.0, confidence = 0.8, minlen = 2, maxlen = 2))
inspect(subset(reglas, confidence == 1.0))

booleansPokestops = subset(ds, select = c(pokestopIn100m, pokestopIn250m, pokestopIn500m, pokestopIn1000m, pokestopIn2500m, pokestopIn5000m))
reglas = apriori(booleansPokestops, parameter = list(support = 0.0, confidence = 0.8, minlen = 2, maxlen = 2))
inspect(subset(reglas, confidence == 1.0))
```

Hemos obtenido las distintas reglas de asociaci칩n sin atender al soporte ya que no estamos interesados en saber cuantas veces se da una correspondencia entre dos hechos (el soporte de dicha regla), lo que queremos saber es que cuando se da un hecho, esto implica que se den los que suponemos que deberian darse (la confianza de las reglas encontradas). Por tanto, como podemos ver, las reglas de asociaci칩n encontradas prueban nuestras suposiciones. Dado esto, procedemos a elminar los atributos. Dado que la confianza es del 100%, no afecta haber usado el conjunto entero.

```{r}
ds <- subset(ds, select = -c(gymIn100m, gymIn250m, gymIn500m, gymIn1000m, gymIn2500m, gymIn5000m, pokestopIn100m, pokestopIn250m, pokestopIn500m, pokestopIn1000m, pokestopIn2500m, pokestopIn5000m))
```
Este dataset nos proporciona una serie de atributos para la localizaci칩n del pokemon. Los primeros que nos encontramos son **latitude** y **longitude**, se tratan de coordenadas geogr치ficas. Por otro lado aparecen **cellId_90m**, **cellId_180m**, **cellId_370m**, **cellId_730m**, **cellId_1460m**, **cellId_2920m**, **cellId_5850m**. Estos indican la posici칩n geogr치fica usando celdas s2. Estas celdas se clasifican en niveles atendiendo a su 치rea, desde 0 (menor 치rea) a 30 (mayor 치rea). Se obtienen seg칰n longitud y latitud, por lo que son la misma informaci칩n representada de distinta manera. Adem치s para m칠todos que dependen de una distancia como el KNN tendr칤amos que investigar la distancia entre las distintas celdas a trav칠s de su ID, lo que supondr칤a una carga de trabajo extra e innecesaria. Se puede consultar m치s informaci칩n sobre las celdas s2 en el siguiente [enlace](http://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/)

Por lo comentando arriba se va a optar a eliminar los atributos correspondientes a las celdas, dejando los atributos **latitude** y **longitude** como los 칰nicos para determinar la posici칩n.

```{r}
ds <- subset(ds, select = -c(cellId_90m, cellId_180m, cellId_370m, cellId_730m, cellId_1460m, cellId_2920m, cellId_5850m))
```

TODO: explicaci칩n de por qu칠 quitamos la ciudad y el continente:

```{r}
ds <- subset(ds, select = -c(city, continent))
```

Por otro lado al explorar el dataset observamos que en el atributo **appearedDayOfWeek** se tomaba el valor *dummy_day*, y al consultar los valores que toma este atributo a lo largo del dataset vimos que no aparecia el lunes cuando el resto de los dias de la semana si que aparecen, con lo cual procedemos a revisar si este valor del atributo se corresponde con el lunes o es simplemente un valor perdido:

```{r}
unique(ds$appearedDayOfWeek)
unique(subset(ds, appearedDayOfWeek == "dummy_day")$appearedMonth)
unique(subset(ds, appearedDayOfWeek == "dummy_day")$appearedDay)
```

Como podemos observar el 칰nico d칤a en el que se registran observaciones en las que el atributo toma el valor *dummy_day* es el 8 de agosto que efectivamente fue un lunes. Adem치s mientras se comprobaba este hecho hemos observado que todas las observaciones se realizaron en agosto y que adem치s fue durante una semana de agosto, con lo cual el atributo **appearedMonth** no aporta ninguna informaci칩n y adem치s los atributos **appearedDayOfWeek** y **appearedDay** aportan la misma informaci칩n, ya que al tomarse las muestras durante una sola semana hay una correspondencia biyectiva entre los valores de ambos atributos. Y como a priori no consideramos que la distancia entre d칤as sea significativa, vamos a optar por quedarnos con el atributo categ칩rico:

```{r}
#le damos un categor칤a m치s singnificativa que dummy_day al atributo
levels(ds$appearedDayOfWeek)[1] <- "Monday"

#vemos los meses y d칤as en los que se tomaron las muestras
unique(ds$appearedMonth)
unique(ds$appearedDay)

#eliminamos las variables innecesarias
ds <- subset(ds, select = -c(appearedMonth, appearedDay))
```

Con lo cual como vemos el n칰mero de muestras y de atributos es muy elevado. Adem치s el n칰mero de clases a clasificar es muy elevado por lo tanto lo que vamos a hacer es intentar clasificar los pokemon seg칰n su tipo, as칤 que vamos a a침adir dicha columna al dataset. Los tipos considerados son aquellos que se establecieron en la primera generaci칩n de Pokemon y se recogen por medio de las siguientes variables que almacenan una cadena indicando el tipo; estas variables se han a침adido por comodidad a la hora de generar el vector de tipos que crearemos a continuaci칩n:

```{r}
P = "planta"
A = "agua"
F = "fuego"
B = "bicho"
G = "fantasma"
L = "lucha"
N = "normal"
E = "electrico"
S = "psiquico"
V = "veneno"
H = "hielo"
D = "dragon"
T = "tierra"
R = "roca"
```


A continuaci칩n formamos un array considerando el tipo primario de cada pokemon de la primera generaci칩n, dando lugar a un array de 151 elementos. Pese que en la app hay algunas especies de pokemon que no aparecen por motivos de indexaci칩n, ya que las muestras dan la clase seg칰n el n칰mero original del pokemon, introducimos el tipo de los 151 pokemon:

```{r}
tipos = c(P,P,P,F,F,F,A,A,A,B,B,B,
  B,B,B,N,N,N,N,N,N,N,V,V,
  E,E,T,T,V,V,V,V,V,V,N,N,
  F,F,N,N,V,V,P,P,P,B,B,B,
  B,T,T,N,N,A,A,L,L,F,F,A,
  A,A,S,S,S,L,L,L,P,P,P,A,
  A,R,R,R,F,F,A,A,E,E,N,N,
  N,A,A,V,V,A,A,G,F,F,R,S,
  S,A,A,E,E,P,P,T,T,L,L,N,
  V,V,T,T,N,P,N,A,A,A,A,A,
  A,S,B,H,E,F,B,N,A,A,A,N,
  N,A,E,F,N,R,R,R,R,R,N,H,
  E,F,D,D,D,S,S)

nombres = c("Bulbasaur", "Ivysaur", "Venusaur", "Charmander", "Charmeleon", "Charizard", "Squirtle", "Wartortle", "Blastoise", "Caterpie", "Metapod", "Butterfree", "Weedle", "Kakuna", "Beedrill", "Pidgey", "Pidgeotto", "Pidgeot", "Rattata", "Raticate", "Spearow", "Fearow", "Ekans", "Arbok", "Pikachu", "Raichu", "Sandshrew", "Sandslash", "NidoranH", "Nidorina", "Nidoqueen", "NidoranM", "Nidorino", "Nidoking", "Clefairy", "Clefable","Vulpix", "Ninetales", "Jigglypuff", "Wigglytuff", "Zubat", "Golbat", "Oddish", "Gloom", "Vileplume", "Paras", "Parasect", "Venonat", "Vanomoth", "Diglett", "Dugtrio", "Meowth", "Persian", "Psyduck", "Golduck", "Mankey", "Primeape", "Growlithe", "Arcanine", "Poliwag", "Poliwhirl", "Poliwrath", "Abra", "Kadabra", "Alakazam", "Machop", "Machoke", "Machamp", "Bellsprout", "Weepinbell", "Victreebel", "Tentacool", "Tentacruel", "Geodude", "Graveler", "Golem", "Ponyta", "Rapidash", "Slowpoke", "Slowbro", "Magnemite", "Magneton", "Farfetch'd", "Doduo", "Dodrio", "Seel", "Dewgong", "Grimer", "Muk", "Shellder", "Cloyster", "Gastly", "Haunter", "Gengar", "Onix", "Drowzee", "Hypno", "Krabby", "Kingler", "Voltorb", "Electrode", "Exeggcute", "Exeggutor", "Cubone", "Marowak", "Hitmonlee", "Hitmonchan", "Lickitung", "Koffing", "Weezing", "Rhyhorn", "Rhydon", "Chansey", "Tangela", "Kangaskhan", "Horsea", "Seadra", "Goldeen", "Seaking", "Staryu", "Starmie", "Mr. Mime", "Scyther", "Jynx", "Electrabuzz", "Magmar", "Pinsir", "Tauros", "Magikarp", "Gyarados", "Lapras", "Ditto", "Evee", "Vaporeon", "Jolteon", "Flareon", "Porygon", "Omanyte", "Omastar", "Kabuto", "Kabutops", "Aerodactyl", "Snorlax", "Articuno", "Zapdos", "Moltres", "Dratini", "Dragonair", "Dragonite", "Mewtwo", "Mew")
```

Ahora vamos a proceder a a침adir la columna de tipos al dataset que hemos cargado, as칤 como el nombre del pokemon observado:

```{r}
ds["tipo"] <- tipos[ds$class]
ds["nombre"] <- nombres[ds$class]
```

Veamos entonces c칩mo se distribuyen las muestras que tenemos seg칰n el tipo de pokemon avistado:

```{r}
T <- xtabs(~ tipo, ds)
etiquetas = c("agua", "bicho", "dragon", "electrico", "fantasma", "fuego", "hielo", "lucha", "normal", "planta", "psiquico", "roca", "tierra", "veneno")
print(T)
colores = rev(c("darkorchid", "burlywood3","darkgoldenrod4", "pink", "forestgreen", "darkgray", "brown4", "cyan2", "red", "midnightblue", "yellow", "slateblue4", "yellowgreen", "dodgerblue"))
barplot(T, main = "Distribuci칩n de tipos", horiz = TRUE, ylab= "Tipo", col = colores, legend.text = etiquetas, args.legend=list(bty = "n", x = "right"))
```

Como podemos ver una vez que hemos agrupado las muestras por el tipo de Pokemon vemos que las clases est치n tremendamente desequilibradas. Mientras que hay much칤simos avistamientos de Pokemon de tipo normal, las clases hielo, drag칩n, fastasma, el칠ctrico o roca resultan marginales. Con lo cual en primer lugar hemos de realizar un equilibrado de estas clases.

Dado que el n칰mero de clases es muy grande hemos, a칰n habiendo agrupado por tipo de pokemon las muestras, hemos optado por quedarnos s칩lo con 5 clases. La elecci칩n ha sido quedarnos con las clases agua, fuego, planta, psiqu칤co y fantasma.

```{r}

#reglasGenerales <- apriori(ds[, -c(1, 2, 3, 5, 6, 8, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23, 24, 29, 182, 183, 184)], parameter = list(support = 0.1, confidence = 0.8, minlen = 2, maxlen = 3, maxtime=300))
```
```{r}
#inspect(reglasGenerales)
```
```{r}
#unique(ds[ds$appearedDayOfWeek=="Sunday",]$pokemonId)
```

```{r}
dsFiltrado <- ds[ds$tipo %in% c("agua", "fuego", "planta", "psiquico", "fantasma"), ]

T <- xtabs(~ tipo, dsFiltrado)
etiquetas = c("agua", "fantasma", "fuego", "planta", "psiquico")
print(T)
colores = rev(c("pink", "forestgreen", "red", "midnightblue", "dodgerblue"))
barplot(T, main = "Distribuci칩n de tipos", ylab= "Tipo", col = colores, legend.text = etiquetas, args.legend=list(bty = "n", x = "right"))
nrow(dsFiltrado)
```

Vamos a realizar un submuestreo aleatorio de modo que nos quedemos con 1000 muestras distintas de cada clase y otras 500 diferentes de cada clase para formar nuestro conjunto de test:

```{r}
index <- lapply(c("agua", "fantasma", "fuego", "planta", "psiquico"), function(tipo) sample(which(dsFiltrado$tipo == tipo), 1500))
nrow(dsFiltrado[index[[1]], ])
unique(dsFiltrado[index[[1]], ]$tipo)
```


```{r}
ds$appearedTimeOfDay <- factor(ds$appearedTimeOfDay, levels = c("morning", "afternoon", "evening", "night"))
tabla <- table(ds$appearedTimeOfDay, ds$tipo)
tabla1 <- table(ds[! ds$tipo %in% c("normal", "bicho", "agua", "dragon", "hielo", "veneno"), c("appearedTimeOfDay", "tipo")])
tabla2 <- table(ds[ds$tipo %in% c("normal", "bicho", "agua", "veneno"), c("appearedTimeOfDay", "tipo")])
tabla3 <- table(ds[ds$tipo %in% c("dragon","hielo"), c("appearedTimeOfDay", "tipo")])
barplot(tabla1, legend = levels(ds$appearedTimeOfDay), las = 2, col = c("darkgoldenrod2", "chocolate", "cyan4", "blue4"))
barplot(tabla2, legend = levels(ds$appearedTimeOfDay), las = 2, col = c("darkgoldenrod2", "chocolate", "cyan4", "blue4"))
barplot(tabla3, legend = levels(ds$appearedTimeOfDay), las = 2, col = c("darkgoldenrod2", "chocolate", "cyan4", "blue4"))
```

Aqu칤 podemos apreciar que para cualquier tipo de pokemon la mayor칤a de los avistamientos se producen durante la noche. Cre칤amos que ibamos a apreciar una tendencia en la que los pokemon de tipo fantasma fuesen los que presentaban este comportamiento de una forma m치s acusada, sin embargo todos los tipos siguen este patr칩n de aparici칩n.

```{r}
unosDatos <- ds[ds$nombre == "Abra" | ds$nombre == "Kadabra",]
tabla <- table(unosDatos$nombre, unosDatos$population_density)
plot(unosDatos$population_density, type = "l")
```

Una de las principales caracter칤sticas de Pokemon GO, aplicaci칩n de la cual son estos datos, es la posibilidad de encontrar pokemon en cualquier parte, por ejemplo en entornos cercanos al agua. Se espera, como es natural, que la mayor칤a de pokemon tipo agua se encuentren en zonas cercanas al agua. Esto dar칤a un gran grado de realismo a la aplicaci칩n. Vamos a comprobar si esto es cierto con el tipo agua y a su vez con algunos otros. Para ello vamos a realizar una sere de gr치ficos.

```{r}
tabla3 <- table(ds$closeToWater, ds$tipo)
barplot(tabla3, legend = levels(ds$closeToWater), las = 2, col = c("burlywood4", "deepskyblue3"), horiz = TRUE)

conteo <- merge(count(ds[ds$closeToWater == "true",]$tipo), count(ds$tipo), by = "x")
colnames(conteo) <- c("tipo", "cercaDelAgua", "total")
conteo["proporcion"] <- conteo$cercaDelAgua / conteo$total
conteo[with(conteo, order(-proporcion)), ]
```
Mostramos tanto una gr치fica en la que se puede ver la distribuci칩n de las muestras referentes a cada tipo seg칰n se hayan avistado cerca del agua o no y un ranking ordenado seg칰n la proporci칩n de avistamientos cerca del agua. As칤 vemos que los pokemon de tipo el칠ctrico, drag칩n, agua e hielo son los que aparecen en mayor proporci칩n cerca del agua. Por otro lado los pokemon de tipo fuego, planta, roca, normal y bicho son los que en menor proporci칩n se presentan en zona acuosas. Nos sorprende de este an치lisis dos cosas: que no sean los pokemon de tipo agua los que sean m치s habituales en proporci칩n en zonas acuosas y que los pokemons de tipo planta est칠n en menor proporci칩n en las zonas con agua que en las zonas secas.

Aqu칤 estamos hablando de proporciones, si nos fijamos en cantidades s칤 son los pokemon (despu칠s de los normales) de tipo agua los que aparecen m치s veces cerca del agua, no obstante preferimos atender a las proporciones ya que no queremos hay que tener en cuenta que habr치 unos tipo de pokemon m치s dif칤ciles de encontrar que otros.

Antes hemos estado discutiendo sobre los dias de las apariciones de los diferentes pokemon. Por lo que ahora vamos a ver como se distribuyen dichas apariciones a lo largo de los dias de la semana. Para realizar esto vamos a elegir a los siguientes tipos: ps칤quico, planta, fuego, tierra y roca

```{r}
ds$appearedDayOfWeek <- factor(ds$appearedDayOfWeek, levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
conteoDias <- table(ds$appearedDayOfWeek, ds$tipo)
barplot(conteoDias, las = 2, col = c("gray8", "gray27", "gray41", "gray58","green","green4","forestgreen"), legend = levels(ds$appearedDayOfWeek))

diasSemana <- c("Monday", "Tuesday", "Wednesday", "Thursday")
tablaSemana <- count(ds[ds$appearedDayOfWeek %in% diasSemana, "tipo"])
tablaFinDeSemana <- count(ds[! ds$appearedDayOfWeek %in% diasSemana, "tipo"])
conteoSemana <- merge(tablaSemana, tablaFinDeSemana, by = "x")
colnames(conteoSemana) <- c("tipo", "L-J", "V-D")
conteoSemana
```

Podemos observar que una gran parte de los avistamientos se realizan en el fin de semana, concretamente los s치bados y viernes. Tambi칠n se producen grandes avistamientos los mi칠rcoles y jueves, mientras que el lunes es el d칤a que menos avistamientos se producen. Todo esto tiene sentido, ya que hemos de pensar que los datos que estamos tratando son de un video juego para m칩viles, por lo tanto la mayor actividad, avistamientos, se realizar치n cuando los jugadores dispongan de mayor tiempo libre para jugar, fin de semana.

Dado que contamos con la latitud y longitud de los avistamiento decidimos representarlos en un mapa, pero al pintar 칰nicamente los puntos referentes a avistamientos en Madrid nos encontramos lo siguiente:

```{r}
world_map <- map_data("world")
base_world <- ggplot() + coord_fixed() + xlab("") + ylab("") + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="lightsalmon4", fill="burlywood3")
mapa <- base_world + geom_point(data = ds[ds$nombre == "Tauros",], aes(x = longitude, y = latitude))
mapa
```

Hay puntos que no se sit칰an en Madrid, otros que s칤. Pensamos que podr칤a deberse a un problema con el sistema de coordenadas empleado en el datates y el empleado en el mapa base. Entonces realizamos el siguiente experimento:

```{r}
minLat <- min(ds[ds$city == "Madrid",]$latitude)
maxLat <- max(ds[ds$city == "Madrid",]$latitude)
minLong <- min(ds[ds$city == "Madrid",]$longitude)
maxLong <- max(ds[ds$city == "Madrid",]$longitude)

#Veamos a qu칠 ciudades pertenecen los avistamientos cuya latitud y longitud est치n en el rango de los puntos de Madrid
unique(ds[ds$latitude >= minLat & ds$latitude <= maxLat & ds$longitude >= minLong & ds$longitude <= maxLong,]$city)
```

Como podemos ver hay avistamientos dentro del mismo rango de latitud y longitud que los puntos en Madrid en ciudades tan dispares como Londres, Berl칤n, Nueva York o Sydney en Australia. Por tanto consideramos que el problema es que al haber formado el dataset, como comenta el propio creador del mismo, con datos de distintas fuentes, las coordeandas de estos avistamientos provienen de distintos sistemas de coordenadas, produciendo este tipo de inconsistencias. Por tanto estos datos juntos con los referentes a los ids de las celdas S2 de distinto tama침o que se obtienen, seg칰n se dice en la p치gina principal del dataset, a partir de ellas son datos err칩neos y que no se pueden usar para nuestro estudio. No obstante consideraremos que el atributo referencia a la ciudad del avistamiento s칤 que puede ser correcto y lo mantendremos para nuestro estudio.

```{r}
madrid <- ds[ds$city == "Madrid",]

raro <- ds[ds$nombre == "Tauros",]
unique(raro$city)
unique(raro$continent)
```


DISTRIBUCI칍N de los tipos en el mapa.

```{r}
world_map <- map_data("world")
base_world <- ggplot() + coord_fixed() + xlab("") + ylab("") + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="lightsalmon4", fill="burlywood3")
colores <- rev(c("darkorchid", "burlywood3","darkgoldenrod4", "pink", "forestgreen", "darkgray", "brown4", "cyan2", "red", "midnightblue", "yellow", "slateblue4", "yellowgreen", "dodgerblue"))
escaleta <- scale_colour_manual(name = c("agua", "bicho", "dragon", "electrico", "fantasma", "fuego", "hielo", "lucha", "normal", "planta", "psiquico", "roca", "tierra", "veneno"), values = colores)
mapa <- base_world + geom_point(data = ds, aes(x = longitude, y = latitude, color = ds$tipo)) + escaleta
mapa
```

Distribuci칩n de los tipos de terreno en el mapa

```{r}
world_map <- map_data("world")
base_world <- ggplot() + coord_fixed() + xlab("") + ylab("") + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="lightsalmon4", fill="burlywood3")
mapa <- base_world + geom_point(data = ds, aes(x = longitude, y = latitude, colour = ds$terrainType))
mapa
```

Distribuci칩n de los distintos tipos de clima en el mapa

```{r}
world_map <- map_data("world")
base_world <- ggplot() + coord_fixed() + xlab("") + ylab("") + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="lightsalmon4", fill="burlywood3")
mapa <- base_world + geom_point(data = ds, aes(x = longitude, y = latitude, colour = ds$weather))
mapa
```




Debido a la gran cantidad de muestras y clases del dataset, hemos decidido quedarnos con 5 clases, 5 pokemon, de aproximadamente 1000 muestras cada una.

```{r}
T <- xtabs(~ nombre, ds)
T[nombre = "Exeggcute"]
T[nombre = "Squirtle"]
T[nombre = "Metapod"]
T[nombre = "Meowth"]
T[nombre = "Kakuna"]

nombrePokemonSelecionados = c("Exeggcute", "Squirtle", "Metapod", "Meowth","Kakuna")
dsFiltrado = ds[ds$nombre %in% nombrePokemonSelecionados,]

write.csv(dsFiltrado,file = "5Pokemon.csv",row.names = FALSE)

dsFiltrado <- read.csv("5Pokemon.csv")

```

Hemos decidido quedarnos con los pokemon Exeggcute (1786), Squirtle (1490), Pinsir (1404), Meowth(1757) y Kakuna(1807)


Eliminamos los atributos **pokemonId** y **class**

```{r}
dsFiltrado <- subset(dsFiltrado, select = -c(pokemonId, class))
```

Lo que vamos a hacer es buscar variables que tengan al menos dos valores distintos a lo largo del dataset. Las que solo presenten un valor ser치n eliminadas ya que no aportan ninguna informaci칩n para la clasificaci칩n.

```{r}
indicesAquitar = (apply(dsFiltrado, 2, function(x)length(unique(x))) == 1)

dsFiltrado <- dsFiltrado[, !indicesAquitar]
```


Antes de proceder al uso de 痙boles de decisi蚤 vamos a realizar una normalizaci蚤 de las distintas variables num本icas

```{r}

normalize <- function(x) {
    return ((x - min(x)) / (max(x) - min(x)))
}

dsFiltrado$latitude = normalize( dsFiltrado$latitude)

dsFiltrado$longitude = normalize(dsFiltrado$longitude)

dsFiltrado$temperature = normalize(dsFiltrado$temperature)

dsFiltrado$windSpeed = normalize(dsFiltrado$windSpeed)

dsFiltrado$pressure = normalize(dsFiltrado$pressure)

dsFiltrado$population_density = normalize(dsFiltrado$population_density)

dsFiltrado$gymDistanceKm = normalize(as.numeric(dsFiltrado$gymDistanceKm))

dsFiltrado$pokestopDistanceKm = normalize(as.numeric(dsFiltrado$pokestopDistanceKm))
```

Al intentar usar la funci칩n tree para obtener un 치rbol de decisi칩n obteniamos un error dici칠ndo que ten칤amos una variable categ칩rica con m치s de 32 nivels, usando el c칩digo `str(dsFiltrado)`, observamos que el atributo pokestopDistanceKm era categ칩rico, algo que no conisderamos que tenga mucho sentido. Con lo cual pasamos a transformar este atributo a num칠rico:
```{r}
library("tree")

dsFiltrado$pokestopDistanceKm = as.numeric(as.character(dsFiltrado$pokestopDistanceKm))
```

Este c칩digo nos informa de que se introduce un NA por coerci칩n y explorando el dataset observamos que efectivamente hay un valor perdido, lo que vamos a hacer es eliminar esta muestra ya que tampoco consideramos que perdamos mucha informaci칩n eliminando s칩lo una muestra:

```{r}
idx <- which(is.na(dsFiltrado$pokestopDistanceKm))
dsFiltrado <- dsFiltrado[-idx,]
```

Ya que nos ha pasado esto vamos a comprobar si existe alg칰n valor perdido m치s en nuestro dataset:

```{r}
sum(apply(dsFiltrado, 2, function(x) sum(is.na(x))) == 1)
```

como podemos ver no parece haber m치s valores perdido con los que procedemos a estudiar algunas t칠cnicas de clasificaci칩n sobre este dataset. Comenzaremos con los 치rboles de decisi칩n, en primer lugar lo que haremos es obtener dos particiones de entrenamiento y test. En una primera aproximaci칩n vamos a realizar simplemente un submuestreo aleatorio sin m치s; luego mejoraremos este procedimiento para ver c칩mo afecta la calidad de las particiones a los resultados de clasificaci칩n que obtengamos:

```{r}
set.seed(42)
dsFiltrado = subset(dsFiltrado, select = -c(tipo))
idx = sample(2, 0.7*nrow(dsFiltrado), replace = TRUE, prob = c(0.8, 0.2))
train = dsFiltrado[idx == 1,]
test = dsFiltrado[idx == 2,]
```

```{r}

arbol = tree(nombre ~ ., data = train)
plot(arbol) ; text(arbol)
testPredict = predict(arbol, newdata = test, type = "class")
tt = table(testPredict, test$nombre)
sum(diag(tt))/nrow(test)*100
```

```{r}
library(party)

arbol = ctree(nombre ~ ., data = train)
plot(arbol, type="simple")
```

```{r}
testPredict = predict(arbol, newdata = test)
tt = table(testPredict, test$nombre)
dd = diag(tt)
sum(dd)/nrow(test)*100
```

```{r}
#rpart, rattle, RColorBrewer
library(rpart)
library(rpart.plot)

arbol = rpart(nombre ~ ., data = train)
plot(arbol) ; text(arbol)
rpart.plot(arbol)
testPredict = predict(arbol, newdata = test, type = "class")
tt = table(testPredict, test$nombre)
dd = diag(tt)
sum(dd)/nrow(test)*100
```

Dado los resultados obtenidos utilizando los m俸odos de clasificaci蚤 vamos a proceder a utilizar **random forest**


```{r}
library(randomForest)
library(data.table)
library(ggplot2)
set.seed(42)
idx = sample(2, 0.7*nrow(dsFiltrado), replace = TRUE, prob = c(0.8, 0.2))
train = dsFiltrado[idx == 1,]
test = dsFiltrado[idx == 2,]

modelo = nombre ~.
arbol = randomForest(modelo, data = train)

table(predict(arbol),train$nombre)
arbol

# Get OOB data from plot and coerce to data.table
oobData = as.data.table(plot(arbol))

# Define trees as 1:ntree
oobData[, trees := .I]

# Cast to long format
oobData2 = melt(oobData, id.vars = "trees")
setnames(oobData2, "value", "error")

# Plot using ggplot
ggplot(data = oobData2, aes(x = trees, y = error, color = variable)) + geom_line()


testpred=predict(arbol,newdata=test)
table(testpred,test$nombre)
tt=table(testpred,test$nombre)

dd=diag(tt)
bien=sum(dd)
bien_clasificados=(bien/nrow(test))*100
bien_rf=bien_clasificados
#Bien y mal clasificados
bien_clasificados
100-bien_clasificados

#Precision, Recall y F-measure
ft=0 
m=c(1:nrow(tt))
n=m
prec=n
rec=m
fmes=m
for(i in 1:nrow(tt)){m[i]=sum(tt[i,])}
for(i in 1:nrow(tt)){n[i]=sum(tt[,i])}
for(i in 1:nrow(tt)){prec[i]=dd[i]/m[i]}
for(i in 1:nrow(tt)){rec[i]=dd[i]/n[i]} 
for(i in 1:nrow(tt)){fmes[i]=2*dd[i]/(m[i]+n[i])}
ft=0
for(i in 1:nrow(tt)){ft=ft+(fmes[i]/nrow(tt))}
#Precision
prec

#Recall
rec
#F-measure
fmes
#F-measure total
ft
ft_rf=ft 

```


Pruebas con KNN

```{r}
library(kknn)

set.seed(42)
idx = sample(2, 0.7*nrow(dsFiltrado), replace = TRUE, prob = c(0.8, 0.2))
entrena = dsFiltrado[idx == 1,]
test = dsFiltrado[idx == 2,]

modelo = nombre ~.

arbol.kknn=kknn(formula=modelo,entrena, test, na.action=na.omit(),k=3)
fit=fitted(arbol.kknn)
tt=table(fit,test$nombre)
tt

dd=diag(tt)
bien=sum(dd)
bien_clasificados=(bien/nrow(test))*100
#Bien y mal clasificados
bien_knn=bien_clasificados
bien_clasificados
100-bien_clasificados

```







