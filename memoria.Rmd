---
title: "proyectoTID"
author: "Alejandro Casado Quijada y Gustavo Rivas Gervillas"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(arules)
```

## Introducción

## Descripción del dataset

Este dataset contiene datos recogidos de la aplicacion *PokemonGo*, esta aplicación es un juego de realidad aumeta que emplea el GPS del móvil para principalmente localizar y capturar pokemon en el mundo real. El dataset contiene 296021 muestras cada una de las cuales dispone de los siguientes campos:

* **pokemonId**: el identificador del pokemon, denota su clase.
* **latitude**: latitud de la posición donde se ha localizado el pokemon.
* **longitude**: longitud de la posición donde se ha localizado el pokemon.
* **appearedLocalTime**: momento exacto en el que se encontró el pokemon, con el formato yyyy-mm-ddThh-mm-ss.ms.
* **X_id**: la ficha del dataset no proporciona información sobre qué representa este dato, de hecho hemos [preguntado en la propia web](https://www.kaggle.com/semioniy/predictemall/discussion/24061#144095) pero no hemos obtenido respuesta. No obstante viendo el dataset no parece ser más que una código identificador de la muestra. 
* **cellId 90-5850m**: la localización goegráfica del pokemon proyectada en una celda S2.
* **appearedTimeOfDay**: momento del día en el que apareció el pokemon (night, evening, afternoon, morning).
* **appearedHour**: hora local de una observación del pokemon.
* **appearedMinute**: minuto local de una observación del pokemon.
* **appearedDayOfWeek**: día de la semana en la que se produjo el avistamiento (Monday, Tuesday, Wednesday, Thursday, Friday, Saturdy, Sunday).
* **appearedDay**: día del avistamiento.
* **appearedMonth**: mes del avistamiento.
* **appearedYear**: año del avistamiento.
* **terrainType**: tipo del terreno donde se avistó el pokemon. Este dato viene dado por un valor número según una [tabla de tipos de terreno](http://glcf.umd.edu/data/lc/).
* **closeToWater**: si está el pokemon a 100m del agua o no.
* **city**: ciudad donde se ha visto el pokemon.
* **continent**: continente donde se ha avistado el pokemon.
* **weather**: un string indicando el tiempo que hacía en el momento del avistamiento.
* **temperature**: temperatura en grados Celsius en el momento del avistamiento.
* **windSpeed**: velocidad del viento en el momento del avistamiento km/h.
* **windBearing**: dirección del viento entre 0 y 360 grados.
* **pressure**: presión en el momento del avistamiento en bares.
* **weatherIcon**: el tiempo atmosférico en el momento del avistamiento clasificado según un sistema de categorías más simple que el empleado en *weather* (fog, clear-night, partly-cloudy-night, partly-cloudy-day, cloudy, clear-day, rain, wind).
* **sunriseMinutesMidnight**: tiempo de la aparición relativo al amanecer.
* **sunsetMinutesBefore**: tiempo de la aparición relativo a la puesta de sol.
* **population density**: densidad de población por $km^2$ en un avistamiento.
* **urbal-rural**: cómo de urbana es la localización donde apareció el pokemon relativa a la *population density* (<200 rural, >= 200 && < 400 midUrban, >= 400 && < 800 subUrban, >800 urban).
* **gymDistanceKm**: distancia al gimnasio más cercano al punto de aparición del pokemon.
* **pokestopDistanceKm**: distancia a la pokestop más cercana al punto de aparicion del pokemon.
* **gymIn100m** - **pokestopIn5000m**: son atributos booleanos que indican si hay un gimnasio o una pokestop a 100m/250m/500m/1000m/2500m/5000m de la localización donde se avistó el pokemon.
* **cooc1** - **cooc151**: booleano que indica si el avistamiento de un pokemon coincidió con el de otro (de una clase entre 1 y 151) en un radio de 100m y en un rango de tiempo de 24 horas.
* **class** dice qué pokemon se trata, y en la página del dataset indica que es el atributo a predecir.
## Preprocesamiento

En primer lugar vamos a ver cuántas muestras y atributos tiene nuestro dataset. Además veremos si las clases están balanceadas, para echo emplearemos el comando `xtab`:

```{r}
ds <- read.csv("300k.csv")
```

```{r}
cat("Hay un total de " , nrow(ds) , " muestras.\n")
cat("Cada muestra tiene " , ncol(ds) , " atributos.\n")
```

Vamos a proceder a eliminar el atributo **appearedLocalTime**, la eliminamos en primer lugar por la dificultad de trabajar con este dado, el cual podríamos transformar en una serie de variables que desglosasen su contenido, no obstante tenemos otros atributos que ya lo hacen, como son la hora, el día, el mes y el año del avistamiento. Por otro lado vamos a eleminar también el atributo **X_id** que como ya hemos comentado no sabemos qué representa. Además teniendo en cuenta que la aplicación se lanzó el día 6 de julio de 2016, es claro que no el año del avistamiento no aporta ninguna información, con lo que también eleminaremos el atributo **appearedYear**.

```{r}
ds <- subset(ds, select = -c(appearedLocalTime, X_id, appearedYear))
```

Viendo el dataset nos hemos dado cuenta de que para los atributos booleanos que nos indican si hay un gimnasio o una pokeparada a una distancia determinada del lugar de avistamiento del pokemon, siguen un patrón, y es que, al parecer, estas variables lo que indican es si hay un gimnasio o una pokeparada **en un radio** de una determinada longitud, con lo cual en cuanto el atributo que indica si hay un gimansio a una distancia es cierto, el resto de atributos que indican si hay un gimnasio a una distancia mayor también lo son. Lo mismo sucede con las paradas. Entonces una vez hayamos confirmado esto, como la existencia de un gimnasio o una pokeparada en un radio determiando implica la existencia en un radio mayor, podremos eliminar, sin pérdida de información, todos estos atributos y quedarnos únicamente con los atributos **gymDistanceKm** y **pokestopDistanceKm**, que resumirían la información contenida en los otros atributos. Para tratar de comprobar esto vamos a hacer uso de las reglas de asociación con el paquete *arules*:

```{r}
booleansGyms = subset(ds, select = c(gymIn100m, gymIn250m, gymIn500m, gymIn1000m, gymIn2500m, gymIn5000m))
reglas = apriori(booleansGyms, parameter = list(support = 0.0, confidence = 0.8, minlen = 2, maxlen = 2))
inspect(subset(reglas, confidence == 1.0))

booleansPokestops = subset(ds, select = c(pokestopIn100m, pokestopIn250m, pokestopIn500m, pokestopIn1000m, pokestopIn2500m, pokestopIn5000m))
reglas = apriori(booleansPokestops, parameter = list(support = 0.0, confidence = 0.8, minlen = 2, maxlen = 2))
inspect(subset(reglas, confidence == 1.0))
```

Hemos obtenido las distintas reglas de asociación sin atender al soporte ya que no estamos interesados en saber cuantas veces se da una correspondencia entre dos hechos (el soporte de dicha regla), lo que queremos saber es que cuando se da un hecho, esto implica que se den los que suponemos que deberian darse (la confianza de las reglas encontradas). Por tanto, como podemos ver, las reglas de asociación encontradas prueban nuestras suposiciones. Dado esto, procedemos a elminar los atributos. Dado que la confianza es del 100%, no afecta haber usado el conjunto entero.

```{r}
ds <- subset(ds, select = -c(gymIn100m, gymIn250m, gymIn500m, gymIn1000m, gymIn2500m, gymIn5000m, pokestopIn100m, pokestopIn250m, pokestopIn500m, pokestopIn1000m, pokestopIn2500m, pokestopIn5000m))
```


Con lo cual como vemos el número de muestras y de atributos es muy elevado. Además el número de clases a clasificar es muy elevado por lo tanto lo que vamos a hacer es intentar clasificar los pokemon según su tipo, así que vamos a añadir dicha columna al dataset. Los tipos considerados son aquellos que se establecieron en la primera generación de Pokemon y se recogen por medio de las siguientes variables que almacenan una cadena indicando el tipo; estas variables se han añadido por comodidad a la hora de generar el vector de tipos que crearemos a continuación:

```{r}
P = "planta"
A = "agua"
F = "fuego"
B = "bicho"
G = "fantasma"
L = "lucha"
N = "normal"
E = "electrico"
S = "psiquico"
V = "veneno"
H = "hielo"
D = "dragon"
T = "tierra"
R = "roca"
```


A continuación formamos un array considerando el tipo primario de cada pokemon de la primera generación, dando lugar a un array de 151 elementos. Pese que en la app hay algunas especies de pokemon que no aparecen por motivos de indexación, ya que las muestras dan la clase según el número original del pokemon, introducimos el tipo de los 151 pokemon:

```{r}
tipos = c(P,P,P,F,F,F,A,A,A,B,B,B,
  B,B,B,N,N,N,N,N,N,N,V,V,
  E,E,T,T,V,V,V,V,V,V,N,N,
  F,F,N,N,V,V,P,P,P,B,B,B,
  B,T,T,N,N,A,A,L,L,F,F,A,
  A,A,S,S,S,L,L,L,P,P,P,A,
  A,R,R,R,F,F,A,A,E,E,N,N,
  N,A,A,V,V,A,A,G,F,F,R,S,
  S,A,A,E,E,P,P,T,T,L,L,N,
  V,V,T,T,N,P,N,A,A,A,A,A,
  A,S,B,H,E,F,B,N,A,A,A,N,
  N,A,E,F,N,R,R,R,R,R,N,H,
  E,F,D,D,D,S,S)
```

Ahora vamos a proceder a añadir la columna de tipos al dataset que hemos cargado:

```{r}
ds["tipo"] <- tipos[ds$class]
```

Veamos entonces cómo se distribuyen las muestran que tenemos según el tipo de pokemon avistado:

```{r}
T <- xtabs(~ tipo, ds)
etiquetas = c("agua", "bicho", "dragon", "electrico", "fantasma", "fuego", "hielo", "lucha", "normal", "planta", "psiquico", "roca", "tierra", "veneno")
print(T)
colores = rev(c("darkorchid", "burlywood3","darkgoldenrod4", "pink", "forestgreen", "darkgray", "brown4", "cyan2", "red", "midnightblue", "yellow", "slateblue4", "yellowgreen", "dodgerblue"))
barplot(T, main = "Distribución de tipos", horiz = TRUE, ylab= "Tipo", col = colores, legend.text = etiquetas, args.legend=list(bty = "n", x = "right"))
```

Como podemos ver una vez que hemos agrupado las muestras por el tipo de Pokemon vemos que las clases están tremendamente desequilibradas. Mientras que hay muchísimos avistamientos de Pokemon de tipo normal, las clases hielo, dragón, fastasma, eléctrico o roca resultan marginales. Con lo cual en primer lugar hemos de realizar un equilibrado de estas clases.